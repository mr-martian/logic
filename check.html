<html>
  <head>
    <title>Proof-Checker</title>
    <meta charset="UTF-8" />
    <script src="lodash.js"></script>
    <style>
      .full {
        background: green;
      }
      .empty {
        background: gray;
      }
      .bad {
        background: pink;
      }
      .invalid {
        background: red;
      }
      .badrule {
        background: purple;
      }
    </style>
  </head>
  <body>
    <span>Number of Premises:</span>
    <input type="number" value="1" id="prem" onchange="addprem();"></input>
    <button onclick="update();">Check Proof</button>
    <span>Key:</span>
    <span class="full">Correct</span>
    <span class="empty">Empty</span>
    <span class="bad">Badly formed input</span>
    <span class="badrule">Badly formed rule</span>
    <span class="invalid">Invalid line</span>
    <span>or: ∨ and: ∙ not: ~ implies: ⊃ biconditional: ≡</span>
    <ol id="prems"></ol>
    <hr>
    <ol id="proof"></ol>
    <button onclick="makestate();">Add Statement</button>
    <script>
      var cor = "∨";
      var cand = "∙";
      var cnot = "~";
      var cthen = "⊃";
      var cbicond = "≡";
      var names = {};
      names[cand] = 'and'; names[cor] = 'or'; names[cthen] = 'implies'; names[cbicond] = 'bicond';
      var cexists = "∃";
      var rules1 = {
        DN: [
          {
            form: {left: 0, op: 'not', right: {left: 0, op: 'not', right: {op: 'var', left: 0, right: 'x'}}},
            result: {op: 'var', left: 0, right: 'x'},
            nest: true
          },
          {
            result: {left: 0, op: 'not', right: {left: 0, op: 'not', right: {op: 'var', left: 0, right: 'x'}}},
            form: {op: 'var', left: 0, right: 'x'},
            nest: true
          }
        ]
      };
      var rules2 = {
        MP: [
          {
            form1: {left: {op: 'var', left: 0, right: 'x'}, op: 'implies', right: {op: 'var', left: 0, right: 'y'}},
            form2: {op: 'var', left: 0, right: 'x'},
            result: {op: 'var', left: 0, right: 'y'}
          }
        ],
        MT: [
          {
            form1: {left: {op: 'var', left: 0, right: 'x'}, op: 'implies', right: {op: 'var', left: 0, right: 'y'}},
            form2: {left: 0, op: 'not', right: {op: 'var', left: 0, right: 'y'}},
            result: {left: 0, op: 'not', right: {op: 'var', left: 0, right: 'x'}}
          }
        ],
        HS: [
          {
            form1: {left: {op: 'var', left: 0, right: 'x'}, op: 'implies', right: {op: 'var', left: 0, right: 'y'}},
            form2: {left: {op: 'var', left: 0, right: 'y'}, op: 'implies', right: {op: 'var', left: 0, right: 'z'}},
            result: {left: {op: 'var', left: 0, right: 'x'}, op: 'implies', right: {op: 'var', left: 0, right: 'z'}}
          }
        ],
        DS: [
          {
            form1: {left: {op: 'var', left: 0, right: 'x'}, op: 'or', right: {op: 'var', left: 0, right: 'y'}},
            form2: {left: 0, op: 'not', right: {op: 'var', left: 0, right: 'x'}},
            result: {op: 'var', left: 0, right: 'y'}
          }
        ],
        CD: [
          {
            form1: {left: {left: {op: 'var', left: 0, right: 'x'}, op: 'implies', right: {op: 'var', left: 0, right: 'y'}},
                    op: 'and',
                    right: {left: {op: 'var', left: 0, right: 'z'}, op: 'implies', right: {op: 'var', left: 0, right: 'w'}}},
            form2: {left: {op: 'var', left: 0, right: 'x'}, op: 'or', right: {op: 'var', left: 0, right: 'z'}},
            result: {left: {op: 'var', left: 0, right: 'y'}, op: 'or', right: {op: 'var', left: 0, right: 'w'}}
          }
        ],
        Conj: [
          {
            form1: {left: 0, op: 'var', right: 'x'},
            form2: {left: 0, op: 'var', right: 'y'},
            result: {left: {left: 0, op: 'var', right: 'x'}, op: 'and', right: {left: 0, op: 'var', right: 'y'}}
          }
        ]
      };
      var statements = {};
      var ids = [null];
      var premisOL = document.getElementById('prems');
      var statementOL = document.getElementById('proof');
      var idnum = 0;
      var parsestatement = function(s) {
        var ret = {left: null, right: null, op: null};
        var path = ['left'];
        var cur = "";
        var c;
        for (var i = 0; i < s.length; i++) {
          c = s[i];
          switch (c) {
            case ' ':
              if (path[path.length-1] == 'left') {
                path.pop();
                path.push('op');
              } break;
            case '~':
              _.set(ret, path, {left: 0, right: null, op: 'not'});
              path.push('right');
              break;
            case '{':
            case '[':
            case '(':
              _.set(ret, path, {left: null, right: null, op: null});
              path.push('left');
              break;
            case ')':
            case ']':
            case '}':
              if (path[path.length-1] != 'right') {
                return -1;
              } else {
                path.pop();
                if (path[path.length-1] == 'left') {
                  path.pop();
                  path.push('op');
                }
              }
              break;
            case cor:
            case cand:
            case cbicond:
            case cthen:
              if (path[path.length-1] == 'right') {
                return -1;
              }
              if (path[path.length-1] == 'left') {
                path.pop();
                path.push('op');
              }
              _.set(ret, path, names[c]);
              path.pop();
              path.push('right');
              break;
            default:
              if (path[path.length-1] != 'op' && typeof(_.result(ret, path)) == 'string') {
                _.set(ret, path, (_.result(ret, path) || '') + c);
              } else if (path[path.length-1] != 'op' && _.result(ret, path) == null) {
                _.set(ret, path, c);
              } else {
                return -1;
              }
          }
        }
        return clean(ret);
      };
      var clean = function(s) {
        if (s.hasOwnProperty('right')) {
          if (s.op == null && s.right == null && s.left != null) {
            return clean(s.left);
          } else if (s.op != null && s.right != null && s.left != null) {
            var l = clean(s.left);
            var o = clean(s.op);
            var r = clean(s.right);
            if (l != -1 && o != -1 && r != -1) {
              return {left: l, op: o, right: r};
            } else {
              return -1;
            }
          } else {
            return -1;
          }
        } else {
          if (s == null) {
            return -1;
          } else {
            return s;
          }
        }
      };
      var fixnums = function() {
        statementOL.setAttribute('start', premisOL.children.length + 1);
      };
      var makeprem = function() {
        var n = document.createElement('li');
        n.innerHTML = '<input type="text">';
        n.id = 'n' + idnum;
        premisOL.appendChild(n);
        idnum++;
        fixnums();
      };
      var makestate = function() {
        var n = document.createElement('li');
        n.innerHTML = '<input type="text"><input type="text">';
        n.id = 'n' + idnum;
        statementOL.appendChild(n);
        idnum++;
      };
      var addprem = function() {
        var n = premisOL.children.length - parseInt(document.getElementById('prem').value);
        while (n < 0) {
          makeprem();
          n++;
        }
        update();
        var em = document.getElementsByClassName('empty');
        var emct = 0;
        while (n > 0 && emct < em.length) {
          if (em[emct].parentNode) {
            em[emct].parentNode.removeChild(em[emct]);
            n--;
          }
          emct++;
        }
        document.getElementById('prem').value = parseInt(document.getElementById('prem').value) + n;
        fixnums();
      };
      var parserule = function(r, id) {
        if (r == 'ACP' || r == 'AIP') {
          var prev = statements[ids.indexOf(id)-1];
          if (_.isEqual(prev.path, statements[id].path.slice(0,-1))) {
            return {rule: r, lines: []};
          } else {
            return -1;
          }
        }
        var m = r.match(/^\s*(\d+),?\s*([A-Z]+)\s*$/);
        if (m) {
          if (m[2] in rules1) {
            return {rule: m[2], lines: [ids[parseInt(m[1])]]};
          } else {
            return -1;
          }
        }
        m = r.match(/^\s*(\d+),\s*(\d+),?\s*([A-Z]+)\s*$/);
        if (m) {
          if (m[3] in rules2) {
            return {rule: m[3], lines: [ids[parseInt(m[1])], names[parseInt(m[1])]]};
          } else {
            return -1;
          }
        }
        m = r.match(/^\s*(\d+)\s*-\s*(\d+),?\s*(CP|IP)\s*$/);
        if (m) {
          var s = parseInt(m[1]);
          var e = parseInt(m[2]);
          if (e >= s) {
            return -1;
          }
          if (e != ids.indexOf(id)-1) {
            return -1;
          }
          if (s > 1 && !_.isEqual(statements[ids[s]].path.slice(0,-1), statements[ids[s-1]].path)) {
            return -1;
          }
          if (!_.isEqual(statements[ids[e]].path.slice(0,-1), statements[id].path)) {
            return -1;
          }
          return {rule: m[3], lines: [ids[s], ids[e]]};
        }
        return -1;
      };
      var updatestatements = function(ol, path) {
        var sv;
        var rv;
        var p;
        var node;
        for (var i = 0; i < ol.children.length; i++) {
          node = ol.children[i];
          if (node.tagName == 'ol') {
            updatestatements(node, path.concat(node.id));
          } else {
            sv = _.trim(node.children[0].value);
            rv = _.trim(node.children[1].value);
            if (sv == '') {
              node.className = 'empty';
            } else if (parserule(rv) == -1) {
              node.className = 'badrule';
            } else {
              p = parsestatement(sv);
              statements[node.id] = {value: p, from: parserule(rv, node.id), path: path};
              node.className = (p == -1 ? 'bad' : 'full');
            }
          }
        }
      };
      var matchpat = function(obj, pat, vars) {
        if (pat.op == 'var') {
          if (pat.right in vars) {
            if (!_.isEqual(obj, vars[pat.right])) {
              vars.ok = false;
            }
            return vars;
          }
          vars[pat.right] = obj;
          return vars;
        } else if (_.isEqual(obj, pat)) {
          return vars;
        } else {
          if (obj.hasOwnProperty('left') && pat.hasOwnProperty('left')) {
            vars = matchpat(obj.left, pat.left, vars);
            vars = matchpat(obj.op, pat.op, vars);
            vars = matchpat(obj.right, pat.right, vars);
            return vars;
          }
        }
        vars.ok = false;
        return vars;
      };
      var checkrule = function(inputs, output, forms, result, nested) {
        //nested indicates that a 1-line rule may be only partial, or that a 2-line rule is to be applied backwards.
        if (inputs.length == 2) {
          var vars = matchpat(inputs[0], forms[0], {ok: true});
          if (vars.ok) {
            vars = matchpat(inputs[1], forms[1], vars);
            if (vars.ok) {
              vars = matchpat(output, restult, vars);
            }
          }
          if (!vars.ok && !nested) {
            return checkrule([inputs[1], inputs[0]], output, forms, result, true);
          }
          return vars.ok;
        } else { //just 1
          var vars = matchpat(inputs[0], forms[0], {ok: true});
          if (vars.ok) {
            vars = matchpat(output, result, vars);
          }
          if (!vars.ok && nested) {
            if (inputs[0].hasOwnProperty('left') && inputs[0].op == output.op) {
              var nes = checkrule([inputs[0].left], output.left, forms, result, nested);
              if (nes) {
                vars = matchpat(inputs[0].right, output.right, {ok: true});
                if (vars.ok) {
                  return true;
                }
              }
              nes = checkrule([inputs[0].right], output.right, forms, result, nested);
              if (nes) {
                vars = matchpat(inputs[0].left, output.left, {ok: true});
                if (vars.ok) {
                  return true;
                }
              }
            }
          }
          return vars.ok;
        }
      };
      var isokline = function(id) {
        var n = document.getElementById(id);
        return n && (n.className == 'full' || s.className == 'invalid')
      };
      var validate = function() {
        var node, s, vars, rule, id;
        for (var i = 1; i < ids.length; i++) {
          id = ids[i];
          node = document.getElementById(id);
          s = statements[id];
          if (node.className == 'full' && s.from != 'premis') {
            node.className = 'invalid';
            if (s.from.rule in rules1 && isokline(s.from.lines[0])) {
              rule = rules1[s.from.rule];
              for (var i = 0; i < rule.length; i++) {
                if (checkrule([statements[s.from.lines[0]].value], s.value, [rule[i].form], rule[i].result, rule[1].nest)) {
                  node.className = 'full';
                  break;
                }
              }
            } else {
              if (isokline(s.from.lines[0]) && isokline(s.from.lines[1])) {
                rule = rules2[s.from.rule];
                for (var i = 0; i < rule.length; i++) {
                  if (checkrule([statements[s.from.lines[0]].value, statements[s.from.lines[1]].value], s.value, [rule[i].form1, rule[i].form2], rule[i].result, false)) {
                    node.className = 'full';
                    break;
                  }
                }
              }
            }
            //check this line
            //mark as invalid if either line referred to isn't .full or .invalid
          }
        }
      };
      var update = function() {
        ids = [null];
        var p;
        var v;
        var s;
        for (var i = 0; i < premisOL.children.length; i++) {
          p = premisOL.children[i];
          v = _.trim(p.children[0].value);
          if (v == '') {
            p.className = 'empty';
          } else {
            s = parsestatement(v);
            if (s == -1) {
              p.className = 'bad';
              statements[p.id] = {value: -1, from: 'premis', path: ['main']};
            } else {
              p.className = 'full';
              statements[p.id] = {value: s, from: 'premis', path: ['main']};
            }
          }
          ids.push(p.id);
        }
        updatestatements(statementOL, ['main']);
        validate();
      };
      makeprem();
      makestate();
    </script>
  </body>
</html>
